---
// TODO How to read from Astro content collection files?
// TODO How to validate Astro data with imported TypeScript interface?
import Book from './Book.tsx';
import SvgSymbolBlogpost from './SvgSymbolBlogpost.astro';
import SvgSymbolBook from './SvgSymbolBook.astro';
import SvgSymbolFavorite from './SvgSymbolFavorite.astro';
import SvgSymbolPodcast from './SvgSymbolPodcast.astro';
import {
  getCollection,
  type CollectionEntry,
  type InferEntrySchema,
} from 'astro:content';
const books: CollectionEntry<'book'>[] = (
  await getCollection(
    'book',
    ({ data }: { data: InferEntrySchema<'book'> }) => {
      return !!data.showOnHomepage;
    },
  )
).sort((a, b) => b.data.pubYear - a.data.pubYear);
const gridId = 'astro-grid-generated-id';
// The sort order of generated collections is non-deterministic and platform-dependent. This means that if you are calling getCollection() and need your entries returned in a specific order (e.g. blog posts sorted by date), you must sort the collection entries yourself.
---

<SvgSymbolBlogpost />
<SvgSymbolBook />
<SvgSymbolFavorite />
<SvgSymbolPodcast />

<ul
  class="custom-grid-has-row-behavior relative flex flex-wrap gap-0"
  id={gridId}
>
  {
    books.map(({ id, data }) => (
      <li class="pb-1">
        <Book
          id={id}
          title={data.title}
          author={data.author}
          description={data.description}
          coverUrl={data.coverUrl}
          coverClassName={data.coverClassName}
          externalUrl={data.externalUrl}
          icon={data.icon}
          isbn={data.isbn}
          language={data.language}
          pubYear={data.pubYear}
          updatedYear={data.updatedYear}
        />
      </li>
    ))
  }
</ul>
<script is:inline define:vars={{ gridId }}>
  const layoutContainer = document.getElementById(gridId);
  if (layoutContainer) {
    const tileElements = layoutContainer.children;
    let previousOffset = 0;
    let currentRow = 1;
    for (const /** @type {HTMLElement} */ tileElement of tileElements) {
      if (tileElement.offsetTop > previousOffset) {
        currentRow++;
      }
      previousOffset = tileElement.offsetTop;
      tileElement.classList.add('row');
      tileElement.classList.add('row-' + currentRow);
      if (currentRow % 2) {
        tileElement.classList.add('custom-shifted');
      }
    }
  }
</script>
