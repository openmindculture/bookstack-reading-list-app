---
// TODO How to read from Astro content collection files?
// TODO How to validate Astro data with imported TypeScript interface?
import Book from './Book.tsx';
import SvgSymbolBlogpost from './SvgSymbolBlogpost.astro';
import SvgSymbolBook from './SvgSymbolBook.astro';
import SvgSymbolFavorite from './SvgSymbolFavorite.astro';
import SvgSymbolPodcast from './SvgSymbolPodcast.astro';
import { getCollection, type CollectionEntry } from 'astro:content';
const books: CollectionEntry<'book'>[] = await getCollection('book');

// The sort order of generated collections is non-deterministic and platform-dependent. This means that if you are calling getCollection() and need your entries returned in a specific order (e.g. blog posts sorted by date), you must sort the collection entries yourself.
---

<SvgSymbolBlogpost />
<SvgSymbolBook />
<SvgSymbolFavorite />
<SvgSymbolPodcast />

<ul class="flex flex-wrap gap-0 relative custom-grid-has-row-behavior">
  {
    books.map(({ id, data }) => (
      <li class="pb-1">
        <Book
          id={id}
          title={data.title}
          author={data.author}
          description={data.description}
          coverUrl={data.coverUrl}
          coverClassName={data.coverClassName}
          externalUrl={data.externalUrl}
          icon={data.icon}
          isbn={data.isbn}
          language={data.language}
          pubYear={data.pubYear}
          updatedYear={data.updatedYear}
        />
      </li>

    ))
  }
</ul>
<script>
  document.addEventListener("DOMContentLoaded", (event) => {
    const layoutContainers = document.querySelectorAll('.custom-grid-has-row-behavior');
    for (const layoutContainer of layoutContainers) {
      const verticalGap = parseInt(getComputedStyle(layoutContainer).rowGap, 10);
      const wrappableElements = layoutContainer.children;
      for (const wrappableElement of wrappableElements) {
        const tileElement = wrappableElement as HTMLElement;
        let gappedHeight = tileElement.offsetHeight + verticalGap;
        tileElement.dataset.gappedHeight = String(gappedHeight);
        let offsetRows = Math.round(tileElement.offsetTop / gappedHeight);
        const rowNumber = offsetRows + 1;
        tileElement.classList.add('row-' + rowNumber);
        tileElement.dataset.offsetTop = String(tileElement.offsetTop);
        tileElement.dataset.offsetRows = String(offsetRows);


        tileElement.classList.add((offsetRows % 2) ? 'is-even' : 'is-odd');
      }
    }
  });
</script>
