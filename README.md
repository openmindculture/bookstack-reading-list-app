# Bookstack Reading List App Dev-UX-Lesezeichen, an Astro and React Revival Project

## Status and Demo

[![Netlify Status](https://api.netlify.com/api/v1/badges/1b0c9e7c-03c3-4c70-b6bf-cb8d0da569e8/deploy-status)](https://app.netlify.com/sites/uxdevlesezeichen/deploys)

https://uxdevlesezeichen.netlify.app/ ‚úÖ‚úÖ

https://dev-ux-lesezeichen.de/ ‚úÖ‚úÖ

Tech Stack:

![Astro](doc/img/Astro.svg)
![React](doc/img/React.svg)
![Vite](doc/img/Vite.svg)
![Vitest](doc/img/Vitest.svg)
![Playwright](doc/img/Playwright.svg)
![Storybook](doc/img/Storybook.svg)
![TypeScript](doc/img/TypeScript.svg)
![Tailwind](doc/img/Tailwind.svg)
![git](doc/img/git.svg)
![GitHub](doc/img/GitHub.svg)
![npm](doc/img/npm.svg)

Theme change
- keep the new dx font, but only for the site title
- remove the Adler fallback
- use Atkinson everywhere else
- switch colors to an orange theme matching Orange Rain Light Theme and retro image both found in the DEV post draft for "An AI-Assisted Astro and React Revival Project"

The main purpose of this code base and websites generated using this code is learning and evaluation. This is a work in progress. The code is provided as-is, without any guaranty or liability whatsoever and should be treated as private and non-production-ready. Copyrights and licences might apply. Do not reuse fonts, graphics, text, or code without explicit permission of the respective author or owner. Use the code and the website generated by this code at your own risk! Any code committed to this repository might be used and reused by Ingo Steinke (openmindculture) and their business partners unless forbidden by legal limitations.

## Development and Deployment

### dev server
  - `npm run dev`
  - http://localhost:4321

### build and preview
  - `npm run build`
  - `npm run preview`

### deploy to production
  - `git commit`
  - test in `develop` branch
  - merge into main branch triggers production deploy to Netlify
  - no other pushes or merges should trigger any Netlify action

## Requirements, Description, Acceptance Criteria

Non-Functional Requirements:
  - Write clean code.
  - Follow coding standards and recommendations.
    - Use Storybook.
    - Use Astro.
    - Use React.
    - Use TypeScript.
  - All tests must pass.
    - Use ESLint.
    - Use Storybook.
    - Use Vitest.
    - Use Playwright.
    - Increase test coverage.
  - All tests must pass.

Bookstack, also known as Dev-UX-Bookmarks or Dev-UX-Lesezeichen in German, is meant to be or become an interactive website for browsing and searching literature about UX, DevUX, web development and related topics. The website's header shows a site title and, optionally, a site search and a navigation menu. The main content between header and footer consists of the web app, that starts with a static initial view in a fixed order rendered by astro that requires no JavaScript or TypeScript. An optional interactive search uses React to replace the initial view by dynamic content showing a search result using the same visual representation as the initial view. The data about books consists of entities with title, author, ISBN, a short description, and an optional link to an authoritative source like the author's or publisher's website or a reputable online book shop. Data is presented in a modular architecture consisting of cards that take the visual shape of hexagons in a responsive layout that behaves similar, but not necessarily identical, to a flexible masonry grid card layout on Pinterest.

An optional site footer contains external links, legal notes, and additional descriptive text to help search engines and human users to better understand and find the site and its content.

Extensibility: the software architecture should enable the app to be extended easily without extensive refactoring by adding the following features:
- optional additional detail view: Clicking or tapping on a card should switch the display to a zoomed-in view that focuses the selected content, which should preferably be achieved using only CSS and no React, TypeScript, or JavaScript, and which might use optional animation effects when switching between views. Zoomed detail view states might use their own distinctive URLs or anchor links that, when requested, should result in the app starting with the respective view.
- optional additional permalink feature: dynamic results might use distinct URLs or anchor links. If such a link is used to access the website, it must show the matching content, in which case the static initial view might be skipped.
- optional additional reading list feature: users can bookmark or unbookmark items and make the app show a list of their bookmarked items. This should be implemented as a client-side feature without user accounts, logins, or authentication, preferably using local storage in the browser.
- optional additional suggestion or edit feature: users can suggest or add additional books to be added in the database. This might be implemented as part of the application or it might be an external process like opening a pull request or merge request in the project's Git repository.
- The web app should be designed in a way that it is easy to localize. This does not necessarily imply that there are no fixed strings or text blocks in a nonlocalized version.

### Tech Stack, Non-Functional Requirements

#### Core Technology and Technical Requirements

- Astro
- TypeScript
- Tailwind CSS
- React
- Storybook
- Playwright
- Vite
- npm
- eslint
- markdown

See the [Software Architecture Research and Decisions section](#software-architecture-research-and-decisions) for more information.

#### Accessibility, Usability, Workflow Guidelines

The web app must be accessible, responsive, robust, maintainable, eco-friendly and load quickly.

- Accessibility: the web app must be accessible and responsive
  - the frontend must comply to WCAG 2.1 AAA
  - the frontend should comply to future WCAG versions
  - the frontend must pass automated audits like axe, wave, and the Lighthouse/PageSpeed Accessibility section
  - all links must be focusable and reachable using keyboard navigation
  - all text must be selectable and readable
  - animation effects must only be active unless the user prefers reduced motion
  - every image must have a meaningful alt attribute
  - content must be printable
- Robust: the app and its development process should adhere to the principles of
  - progressive enhancement
  - graceful degradation
  - robustness, i.e. if a partial function breaks or is unavailable, other parts of the application must not be affected. Initial content must be available without JavaScript.
- Maintainability
  - code should be modular and easy to read
  - code style must follow rules and recommendations defined by linter configuration
  - code style should follow official recommendations and best practices
  - code must be linted using eslint
  - code must always be syntactically correct
  - all tests must run successfully
  - npm run build must succeed
  - merge conflicts must be resolved
  - generated code must be reviewed by a human before commit and deployment
  - variables, functions, and files should use meaningful, self-explanatory names
  - JavaScript logic must be written in TypeScript.
  - Using the `any` type must be avoided.
  - Application logic code should be tested or be testable.
  - Test should strive for 100% code coverage.
  - Frontend must be tested using semantic and visual regression tests.
  - Frontend accessibility, animations, and hover states should be tested.
- Loading speed, eco-friendliness, web performance: the application should react quickly,
  - Lighthouse or PageSpeed audits should achieve an overall performance score above 80/100
  - WebsiteCarbon and Ecograder audits should prove above-average test results.
  - The initial page weight must not exceed 1 MB.
  - The web app must be fully interactive within 2 seconds after it finished loading.

Development should either be platform-agnostic or designed to work on Linux and MacOS.

The app should be deployed "in the cloud" (e.g. on Netlify Web Services).
TypeScript is currently only used in the front-end.
The tech stack focuses on Astro, React (ReactJS), TypeScript, Node.js, npm, bash, Vite, Vitest, Tailwind CSS, Storybook, Playwright, Markdown, and HTML5. Software, languages, and libraries should use the latest stable versions and recommendations.

Software architecture and coding should always follow the robustness principle, progressive enhancement, and WCAG-compliant accessibility. Only humans are allowed to commit to the git repository. Only the product owner is allowed to merge into the main branch.

The main branch, `main` is the protected branch for production-ready code. The latest commit in the main branch should be automatically deployed to the production website by an online service like Netlify, unless the automated tests have failed. Code must always be working, tested, and follow all guidelines before getting merged into the main branch. Every successful release should correspond to a git tag.

The development branch, `develop` is the current development state that should be stable enough to use it on localhost and fork new feature branches. Stable enough means that although some tests or requirements may fail, there must be a working website in the local browser after running `npm run dev`.

New features should be developed in a modular way using feature branches in a process similar, but not necessarily identical, to git flow, preferably using atomic commits and trunk-based development against the `develop` branch as the "trunk" of the development process. Feature branches must never be merged into the main branch directly.

Developers and AI assistants should refer to the requirements stated in this document, in optional GitHub issues, and AI-specific instructions in [mainprompt.md](./mainprompt.md) if present and applicable. Generally, developers and assistants should always strive to provide correct, complete, and working code and they should ask for missing project code, documentation, or definitions necessary for an adequate response, instead of guessing.

Generate full code, include clear inline comments or JSDoc headers describing each step of code when necessary, implement error checking and type validation. Implement strict TypeScript notation, defining new types as necessary. Adhere to best practices and coding standards. In Astro, prefer native HTML elements like <head> over overengineered custom elements like <Head> unless they are necessary. Generate working code using the latest stable npm package dependencies and install all dependencies that are needed. Don't generate faulty code that you are able to fix, generate error-free code in the first place! Don't change code based on assumptions, especially if the code is currently correct, don't try to fix it. For example, don't downgrade ESLint based on the false claim that the version 9.29.0 does not exist, if it does.

In TypeScript, do not use the 'any' type. Do not use the non-null assertion operator (`!`). Do not cast to unknown (e.g. `as unknown as T`).  It is critically important that you adhere to the above rules.

## Testing and Development Tech Stack Choices

### Integrating Storybook, React, and Astro

Storybook is framework-agnostic. Stories can be used by React and Astro (which can render React components), The core logic and styling of the component should ideally be independent of any specific framework's internal mechanisms. he component should rely on props for its data and behavior. This makes it easy to pass information from Astro (when using the React integration) or from other React components.

Storybook's official "Intro to Storybook for React" tutorial uses a `Task` component as a core example:

- https://storybook.js.org/tutorials/intro-to-storybook/react/en/simple-component/

### How to implement frontend testing with Vitest, Storybook, and Playwright?

This project, the Bookstack Reading List App showcased at Dev-UX-Lesezeichen.de, aims to combine a handful of modern frontend web development tools, notably Astro, Tailwind, React, Storybook, Vite, Vitest, and Playwright, preferably coding in TypeScript, applying descriptive declarations, and using test-driven development when possible.

- Static Analysis (ESLint)
- Unit tests (Vitest)
- Component tests (Storybook)
- End-to-end tests (Playwright)

We don't need Storyshots for regression testing, especially for visual regression, as it's deprecated. Storybook has often been powered Playwright, which excels at visual regression testing and can take screenshots. Storybook's `play` functions combined with Vitest (running in browser mode with Playwright) or the Storybook test runner are excellent.

### Why do we recommend Vitest Browser Mode?

Why doesn't anyone write unit tests? One of the core issues is that tests typically run in CI in a node.js environment, rather than the code‚Äôs actual target environment, the browser. Vitest's browser mode, although currently under development, and APIs may change in the future, runs your tests in a real browser (Chromium, via **Playwright**, in the default configuration). The alternative is a simulated browser environment, like JSDom or HappyDom, which can have differences in behavior compared to a real browser. This allows to run your tests in the browser natively, providing access to browser globals like window and document, and use Playwright for cross-browser testing.

Sources:
-  https://storybook.js.org/docs/writing-tests/integrations/vitest-addon#why-do-we-recommend-browser-mode
- https://www.defined.net/blog/modern-frontend-testing/

## Background: Motivation and History

The article [Building a Reading List web app with Node, Preact, and Tailwind CSS](https://dev.to/ingosteinke/building-a-reading-list-web-app-with-node-preact-and-tailwind-css-44pa) elaborates on my motivation and project history.

This should have been the first project based on my [Tailwind-JIT-MERN-Starter](https://github.com/openmindculture/tailwind-jit-mern),
which was forked from [Retinafunk's Tailwind-JIT-Starter](https://github.com/retinafunk/tailwind-jit).

[I](https://www.ingo-steinke.com/) migrated it to a simpler proof of concept demo using Astro in 2024 using the Astro Starter Kit and current documentation and tutorials. Development stopped shortly after, due to prioritized paid customer projects. Proceeding in June 2025, inspired by the React Berlin Meetup, Hunor M√°rton¬¥s Astro+React talk, feedback from Freelance Unlocked workshops and AI-assisted "CV hacking" sessions, as well as feedback from fellow developers about the latest advances in AI-assisted coding, the development process and tech stack changed, once again, but only slightly, to Astro + React + Storybook + Tailwind + Vite + Vitest + Playwright, a clear frontend focus with no backend logic like dynamic API, database or serverless functions at all, and including LLM-based coding assistants like Copilot, Windsurf, Gemini, and Jetbrains AI, which is still the preferred AI assistant due to its stability and long-term development by a reputable European company.

## Roadmap
- [x] start initial proof of concept
- [x] document ideas and roadmap
- [x] register domain
- [x] release placeholder text with backlinks
- [x] update requirements and prioritization
  - [x] no backend, 100% focus on the front-end
  - [x] Tailwind without optional extras
  - [x] React (keep it simple and stick to the mainstream)
  - [x] Astro
  - [x] Playwright
- [x] release a minimal viable product/page (MVP)
- [x] research, experiment, and decide on a tech stack
- [x] document requirements and guidelines
- [ ] run audits and document results (Lighthouse, WAVE, WebPageTest, WebsiteCarbon, Green Web Check, and optional services Domain Authority, SEObility, Ubersuggest etc.)
- [ ] list and link the web app to increase incoming backlinks
- [ ] increase test coverage
  - [ ] unit tests
  - [ ] end-to-end tests
  - [ ] frontend tests, including Screenshots and accessibility audits
- [ ] localize app (German and English)
- [ ] add more content

<a id="software-architecture-research-and-decisions"></a>
## Software Architecture Research and Decisions

### Common Modules for Astro, React, and Storybook

> In an Astro project, how can we ensure that the same components can be prototyped and testing in storybook and reused both for static Astro rendering and as part of a dynamic react app?

Seasoned astronaut:

> üßë‚ÄçüöÄ Delete this section. Have fun!

### Project Structure

Inside of your Astro project, you'll see the following folders and files:

```text
/
‚îú‚îÄ‚îÄ public/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ pages/
‚îÇ       ‚îî‚îÄ‚îÄ index.astro
‚îî‚îÄ‚îÄ package.json
```

Astro looks for `.astro` or `.md` files in the `src/pages/` directory. Each page is exposed as a route based on its file name.

There's nothing special about `src/components/`, but that's where we like to put any Astro/React/Vue/Svelte/Preact components.

Any static assets, like images, can be placed in the `public/` directory.

### üßû Astro¬¥s Basic Commands

All commands are run from the root of the project, from a terminal:

| Command                   | Action                                           |
| :------------------------ | :----------------------------------------------- |
| `npm install`             | Installs dependencies                            |
| `npm run dev`             | Starts local dev server at `localhost:4321`      |
| `npm run build`           | Build your production site to `./dist/`          |
| `npm run preview`         | Preview your build locally, before deploying     |
| `npm run astro ...`       | Run CLI commands like `astro add`, `astro check` |
| `npm run astro -- --help` | Get help using the Astro CLI                     |

### Additional Astro Commands

`npm run test` | run all tests
`npm run eslint` | check TypeScript and JS files for correct syntax and best practices

### Build Tools: npm vs. yarn vs. bun vs. ...

> Should we use yarn instead of npm in a project with astro, vite, and react?

For most projects and teams, **npm is a perfectly solid choice**. It's the default, well-understood, and has improved immensely. Consider Yarn, especially Yarn Berry, if you are working in a monorepo and want robust workspace support. Consider pnpm if disk space efficiency is a major concern. Consider Bun if you are starting a new project and you're ready to experiment with a fast, cutting edge tool, that is probably less stable and mature than Yarn or npm. Once you decide (or confirm) the package manager to use, always commit the corresponding lock file.

### Vite vs. Parcel vs. webpack vs. ...

**Vite** heavily leverages esbuild, but it's not built entirely on top of esbuild in the sense that esbuild handles everything. Vite uses esbuild for specific, performance-critical tasks, and combines it with other tools for a complete development and build experience.

**Vite uses esbuild as a transpiler and pre-bundler** during development and for minification, but **relies on Rollup for the more complex production bundling** and its extensive plugin ecosystem. The eventual **plan is to consolidate these roles with Rolldown**.

### Tailwind Takeaways

There is a "Tailwind look and feel" defined by Tailwind's default styles and presets, some of which resemble the Bootstrap framework. **Tailwind's philosophy is to provide sensible defaults and utility classes that lead to good design.**

Quoting my original 2021 notes:

#### Properly Using Conditional Class Names

How to make sure to write dynamic / conditional styles in a detectable way?

So we must avoid string concatenation to create class names. For example `<div class="text-{{ error ? 'red' : 'green' }}-600">` fails to expose the class names to the purge algorithm, thus `.text-red-600 and .text-green-600` will be missing in the exported style sheets unless they are used somewhere else by coincidence.

On the other hand, writing the full class names still allows us to use conditional class names:

```
<div class="{{  error  ?  'text-red-600'  :  'text-green-600'  }}"></div>
```

We also want to load CSS in HTML `<head>`, not in JavaScript: this might unblock load speed by allowing parallel download of CSS and JavaScript, and it also allows us to define styled static page elements outside of our (p)react app, like a footer with links to external or static resources.

#### Linting Tailwind CSS

Tailwind supports writing and using pure CSS that linters can analyze better than the JSX-in-CSS chaos often found in React projects. JIT is now standard, compiling custom CSS to prevent exporting rules that are never used.

#### Built-in Preset Class Names

Tailwind's built-in classes follow different schemas. Its numbers and letters do not imply mathematical accuracy, e.g. `2xl` is not "two times L" or "two times anything". The presence of "8xl" does not imply there is "9xl". Unsuffixed numbers and names are not supposed to be consistent between different contexts, but consistents within the same context, e.g. `text-8xl` is larger than `text-7xl`.

- `mt-4 = margin: 1rem 0 0 0` (when no other `m...` class is present)

#### Tailwind Color Palette

Every color in the default palette includes 11 steps, with 50 being the lightest, and 950 being the darkest. Use color utilities like `bg-white`, `border-pink-300`, and `text-gray-950` to set the different color properties of elements in your design. You can adjust the opacity of a color using syntax like `bg-black/75`, where `75` sets the alpha channel of the color to 75%.

A full list of utilities that use your color palette: https://tailwindcss.com/docs/colors#using-color-utilities

Also consider https://hextotailwind.com/ to find approximate matches of Tailwind built-ins.

#### Typography

Leading, in typography, is pronounced ‚Äúledding‚Äù and refers to the space between lines of text. Tailwind's `text`-prefixed properties set typography and foreground colors. Tailwind's `text-xl` is only `1.25rem`, not really "extra-large". Tailwind has defaults of `text-6xl` and  `text-7xl`, but no `6.5 / 4rem` in between.

- `leading-none = line-height: 1`
- `leading-<number>
line-height: calc(var(--spacing) * <number>)`
- `text-8xl/1 sets both font-size and line-height`
- `leading-[<value>]
line-height: <value>;`

Custom font families must be defined both in `global.css` (`@font-face` rules) and in `tailwind.config.ts` (`theme.extend.fontFamily`).

#### Customizing Tailwind CSS v3

Tailwind can be customized by adding individual classes. In Tailwind CSS v3 this is done in WordPress-like JSON syntax to extend the `theme.extend` configuration object, while Tailwind CSS v4 prefers setting custom properties in `global.css`. A so-called "Tailwind language server" helps IDEs like WebStorm, VSCode, Intellisense, to get auto-completion suggestions correct and show implied `rem` and `px` values.

Extending Taiwlwind's configuration object implicitly creates custom properties like `--color-foo` and sets of CSS rules and class names, like `text-foo` (foreground) and `bg-foo` (background) color classes, `text-clamp-10ch` for a `theme.extend.fontSize.clamp-10ch` configuration key.

Custom `fontSize` classes are prefixed with `text-`, but custom `fontFamily` keys create `font-` classes.

A color configuration object will create color variations with the respective suffixes, like `theme.extend.colors.tahiti.light` implies `text-tahiti { color: var(--color-tahiti-light); }` while `theme.extend.colors.tahiti.DEFAULT` will create a `tahiti` color without a suffix.

#### Customizing Tailwind CSS v4

In Tailwind CSS v4 (alpha/beta, not recommended for astro yet) we would define custom properties in `global.css`:

```css
    @theme {
        --color-my-custom-blue: #1a73e8;
```

#### At-Apply-Rules

We should use Tailwind's at-rule `@apply` to style globals and often-used style combinations to keep our HTML markup clean and maintainable.

So, instead of `<h1 class="font-bold break-words m-0 mt-4 leading-none color-blue-400 text-customfont">' we could use `<h1 class="custom-heading-h1">` or even just `<h1>` with global CSS like below.

```css
h1, .custom-heading-h1 {
  @apply font-bold break-words m-0 mt-4 leading-none color-blue-400 text-customfont;
}
```

### Tech Stack Diversity

At least there is no need to try to connect incompatible CJS (legacy CommonJS) `require` with EJS (ES6+ JS module or mjs) `import` and `export` syntax. **TypeScript** has saved us from React PropTypes, and **Vite** from incomprehensible Webpack configuration. Still, it can take days to screw together a project's tech stack. Still, some islands require an old syntax, like `postcss.config.cjs` or `.astro/content-modules.mjs`. We don't need to rewrite every line of code to TypeScript and that would even break some of our tools.

### Astro + React Integration

- use the `client:load` directive

```
---
import List from './List';
---
<List client:load />
```

We don't need to add `.jsx` or `.tsx` but we should add `.astro` when importing from files.

- trigger hydration only when visible using [client:visible](https://docs.astro.build/en/reference/directives-reference/#clientvisible) with an optional margin (treshold) without needing to write boilerplate code for the implicit `IntersectionObserver`

```
client:visible={{rootMargin: '200px'}}
```

Astro allows use to combine different languages and content types in a single file, keeping together what belongs together in terms of content, forget about **seperation of concerns**, and let Astro's implicit "magic" work on it. This mix risks to become dangerously unmaintainable once it gets too complex, and future syntax changes make it feel less intuitive that it was at the time of writing.

### Separation of Concerns

Are new file formats like `.astro` or `.mdx`, a lenient combination of markdown and JSX properly inspectable by static code analysis (like ESLint) and unit tests (like with Vitest). How can our project structure and code style make it easier for linters and code reviewers to find errors and antipatterns in our Astro code?

Vitest is good at testing Astro components when using Astro's `getViteConfig()` helper in our `vitest.config.ts`. Vitest can test the JavaScript logic contained in `.mdx` files, while ESLint uses Remark to validate the markdown syntax, when we use

- `eslint-plugin-astro`
- `eslint-plugin-mdx`

in our ESLint configuration.

We don't need to separate language syntax, when seemingly mixed languages like 'TSX' do have a clear definition and documentation. But we whould separate responsibilities and break our code into small components that are easy to read, test, and maintain.

Reducing (JS/React-controlled) interactivity to the minimum respects

- the **Islands Architecture** approach
- the **principle of least power**
- progressive enhancement
- web performance

and improves

- load time
- user experience
- maintainability

### Astro: Robust Linting and Formatting Setup:

ESLint with Plugins:

Install and configure eslint-plugin-astro, eslint-plugin-mdx, and @typescript-eslint/parser (if using TypeScript).

Integrate Prettier (using prettier-plugin-astro and eslint-config-prettier) to handle code formatting automatically. This eliminates stylistic debates in code reviews.

Enable recommended rule sets (e.g., plugin:astro/recommended, plugin:mdx/recommended).

@typescript-eslint/parser

**TODO** check and verify, as detailed tips like that seemed to contradict when I last tried?

## Further Reading

https://docs.astro.build/en/guides/styling/#tailwind

https://docs.astro.build/en/guides/integrations-guide/react/

https://eslint.org/docs/latest/use/configure/migration-guide#custom-parsers

https://github.com/storybookjs/storybook/discussions/24835

https://github.com/storybookjs/storybook/discussions/28386

https://storybook.js.org/docs/writing-tests/integrations/vitest-addon

https://tailwindcss.com/docs/font-family

https://docs.astro.build/en/reference/configuration-reference/

https://docs.astro.build/en/guides/typescript/

