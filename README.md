# Bookstack Reading List App Dev-UX-Lesezeicheen, an AI-Assisted Astro and React Revival Project

## Status and Demo

![GitHub CI status for development branch](https://github.com/openmindculture/bookstack-reading-list-app/workflows/ci/badge.svg?branch=development)

[![Netlify Status](https://api.netlify.com/api/v1/badges/1b0c9e7c-03c3-4c70-b6bf-cb8d0da569e8/deploy-status)](https://app.netlify.com/sites/uxdevlesezeichen/deploys)

https://uxdevlesezeichen.netlify.app/

https://dev-ux-lesezeichen.de/

TODO: 
- configuration fix
- keep custom style snippets,
- but reinstall && reconfigure
  Astro + React + Tailwind ( + Vite )
- according to official best practice
- preferably without AI
- preferably using stable Tailwind 3

to find a
working best-practice intergration of astro, vite and tailwind that is not deprecated and that does not cause npm peer dependency conflicts. Or just point me to an authoritative example that shows how to integrate astro, vite, and tailwindcss properly.


Starting points might be:

https://docs.astro.build/en/guides/styling/#tailwind

https://docs.astro.build/en/guides/integrations-guide/react/



theme change
- keep the new dx font, but only for the site title
- remove the Adler fallback
- use Atkinson everywhere else
- switch colors to an orange theme matching Orange Rain Light Theme and retro image both found in the DEV post draft for "An AI-Assisted Astro and React Revival Project"

The main purpose of this code base and websites generated using this code is learning and evaluation. This is a work in progress. The code is provided as-is, without any guaranty or liability whatsoever and should be treated as private and non-production-ready. Copyrights and licences might apply. Do not reuse fonts, graphics, text, or code without explicit permission of the respective author or owner. Use the code and the website generated by this code at your own risk! Any code committed to this repository might be used and reused by Ingo Steinke (openmindculture) and their business partners unless forbidden by legal limitations.

## Development and Deployment

### dev server
  - `npm run dev`
  - http://localhost:4321

### build and preview
  - `npm run build`
  - `npm run preview`

### deploy to production
  - `git commit`
  - test in `develop` branch
  - merge into main branch triggers production deploy to Netlify

## Requirements, Description, Acceptance Criteria

Non-Functional Requirements:
  - Write clean code.
  - Follow coding standards and recommendations.
    - Use Storybook.
    - Use Astro.
    - Use React.
    - Use TypeScript.
  - All tests must pass.
    - Use ESLint.
    - Use Storybook.
    - Use Vitest.
    - Use Playwright.
    - Increase test coverage.
  - All tests must pass.

Bookstack, also known as Dev-UX-Bookmarks or Dev-UX-Lesezeichen in German, is meant to be or become an interactive website for browsing and searching literature about UX, DevUX, web development and related topics. The website's header shows a site title and, optionally, a site search and a navigation menu. The main content between header and footer consists of the web app, that starts with a static initial view in a fixed order rendered by astro that requires no JavaScript or TypeScript. An optional interactive search uses React to replace the initial view by dynamic content showing a search result using the same visual representation as the initial view. The data about books consists of entities with title, author, ISBN, a short description, and an optional link to an authoritative source like the author's or publisher's website or a reputable online book shop. Data is presented in a modular architecture consisting of cards that take the visual shape of hexagons in a responsive layout that behaves similar, but not necessarily identical, to a flexible masonry grid card layout on Pinterest.

An optional site footer contains external links, legal notes, and additional descriptive text to help search engines and human users to better understand and find the site and its content.

Extensibility: the software architecture should enable the app to be extended easily without extensive refactoring by adding the following features:
- optional additional detail view: Clicking or tapping on a card should switch the display to a zoomed-in view that focuses the selected content, which should preferably be achieved using only CSS and no React, TypeScript, or JavaScript, and which might use optional animation effects when switching between views. Zoomed detail view states might use their own distinctive URLs or anchor links that, when requested, should result in the app starting with the respective view.
- optional additional permalink feature: dynamic results might use distinct URLs or anchor links. If such a link is used to access the website, it must show the matching content, in which case the static initial view might be skipped.
- optional additional reading list feature: users can bookmark or unbookmark items and make the app show a list of their bookmarked items. This should be implemented as a client-side feature without user accounts, logins, or authentication, preferably using local storage in the browser.
- optional additional suggestion or edit feature: users can suggest or add additional books to be added in the database. This might be implemented as part of the application or it might be an external process like opening a pull request or merge request in the project's Git repository.
- The web app should be designed in a way that it is easy to localize. This does not necessarily imply that there are no fixed strings or text blocks in a nonlocalized version.

### Tech Stack, Non-Functional Requirements

#### Core Technology and Technical Requirements

- Astro
- TypeScript
- Tailwind CSS
- React
- Storybook
- Playwright
- Vite
- npm
- eslint
- markdown

See the [Software Architecture Research and Decisions section](#software-architecture-research-and-decisions) for more information.

#### Accessibility, Usability, Workflow Guidelines

The web app must be accessible, responsive, robust, maintainable, eco-friendly and load quickly.

- Accessibility: the web app must be accessible and responsive
  - the frontend must comply to WCAG 2.1 AAA
  - the frontend should comply to future WCAG versions
  - the frontend must pass automated audits like axe, wave, and the Lighthouse/PageSpeed Accessibility section
  - all links must be focusable and reachable using keyboard navigation
  - all text must be selectable and readable
  - animation effects must only be active unless the user prefers reduced motion
  - every image must have a meaningful alt attribute
  - content must be printable
- Robust: the app and its development process should adhere to the principles of
  - progressive enhancement
  - graceful degradation
  - robustness, i.e. if a partial function breaks or is unavailable, other parts of the application must not be affected. Initial content must be available without JavaScript.
- Maintainability
  - code should be modular and easy to read
  - code style must follow rules and recommendations defined by linter configuration
  - code style should follow official recommendations and best practices
  - code must be linted using eslint
  - code must always be syntactically correct
  - all tests must run successfully
  - npm run build must succeed
  - merge conflicts must be resolved
  - generated code must be reviewed by a human before commit and deployment
  - variables, functions, and files should use meaningful, self-explanatory names
  - JavaScript logic must be written in TypeScript.
  - Using the `any` type must be avoided.
  - Application logic code should be tested or be testable.
  - Test should strive for 100% code coverage.
  - Frontend must be tested using semantic and visual regression tests.
  - Frontend accessibility, animations, and hover states should be tested.
- Loading speed, eco-friendliness, web performance: the application should react quickly,
  - Lighthouse or PageSpeed audits should achieve an overall performance score above 80/100
  - WebsiteCarbon and Ecograder audits should prove above-average test results.
  - The initial page weight must not exceed 1 MB.
  - The web app must be fully interactive within 2 seconds after it finished loading.

Development should either be platform-agnostic or designed to work on Linux and MacOS.

The app should be deployed "in the cloud" (e.g. on Netlify Web Services).
TypeScript is currently only used in the front-end.
The tech stack focuses on Astro, React (ReactJS), TypeScript, Node.js, npm, bash, Vite, Vitest, Tailwind CSS, Storybook, Playwright, Markdown, and HTML5. Software, languages, and libraries should use the latest stable versions and recommendations.

Software architecture and coding should always follow the robustness principle, progressive enhancement, and WCAG-compliant accessibility. Only humans are allowed to commit to the git repository. Only the product owner is allowed to merge into the main branch.

The main branch, `main` is the protected branch for production-ready code. The latest commit in the main branch should be automatically deployed to the production website by an online service like Netlify, unless the automated tests have failed. Code must always be working, tested, and follow all guidelines before getting merged into the main branch. Every successful release should correspond to a git tag.

The development branch, `develop` is the current development state that should be stable enough to use it on localhost and fork new feature branches. Stable enough means that although some tests or requirements may fail, there must be a working website in the local browser after running `npm run dev`.

New features should be developed in a modular way using feature branches in a process similar, but not necessarily identical, to git flow, preferably using atomic commits and trunk-based development against the `develop` branch as the "trunk" of the development process. Feature branches must never be merged into the main branch directly.

Developers and AI assistants should refer to the requirements stated in this document, in optional GitHub issues, and AI-specific instructions in [mainprompt.md](./mainprompt.md) if present and applicable. Generally, developers and assistants should always strive to provide correct, complete, and working code and they should ask for missing project code, documentation, or definitions necessary for an adequate response, instead of guessing.

Generate full code, include clear inline comments or JSDoc headers describing each step of code when necessary, implement error checking and type validation. Implement strict TypeScript notation, defining new types as necessary. Adhere to best practices and coding standards. In Astro, prefer native HTML elements like <head> over overengineered custom elements like <Head> unless they are necessary. Generate working code using the latest stable npm package dependencies and install all dependencies that are needed. Don't generate faulty code that you are able to fix, generate error-free code in the first place! Don't change code based on assumptions, especially if the code is currently correct, don't try to fix it. For example, don't downgrade ESLint based on the false claim that the version 9.29.0 does not exist, if it does.

In TypeScript, do not use the 'any' type. Do not use the non-null assertion operator (`!`). Do not cast to unknown (e.g. `as unknown as T`).  It is critically important that you adhere to the above rules.

## Testing and Development Tech Stack Choices

### Integrating Storybook, React, and Astro

Storybook is framework-agnostic. Stories can be used by React and Astro (which can render React components), The core logic and styling of the component should ideally be independent of any specific framework's internal mechanisms. he component should rely on props for its data and behavior. This makes it easy to pass information from Astro (when using the React integration) or from other React components.

Storybook's official "Intro to Storybook for React" tutorial uses a `Task` component as a core example:

- https://storybook.js.org/tutorials/intro-to-storybook/react/en/simple-component/

### How to implement frontend testing with Vitest, Storybook, and Playwright?

This project, the Bookstack Reading List App showcased at Dev-UX-Lesezeichen.de, aims to combine a handful of modern frontend web development tools, notably Astro, Tailwind, React, Storybook, Vite, Vitest, and Playwright, preferably coding in TypeScript, applying descriptive declarations, and using test-driven development when possible.

- Static Analysis (ESLint)
- Unit tests (Vitest)
- Component tests (Storybook)
- End-to-end tests (Playwright)

We don't need Storyshots for regression testing, especially for visual regression, as it's deprecated. Storybook has often been powered Playwright, which excels at visual regression testing and can take screenshots. Storybook's `play` functions combined with Vitest (running in browser mode with Playwright) or the Storybook test runner are excellent.

### Why do we recommend Vitest Browser Mode?

Why doesn't anyone write unit tests? One of the core issues is that tests typically run in CI in a node.js environment, rather than the codeâ€™s actual target environment, the browser. Vitest's browser mode, although currently under development, and APIs may change in the future, runs your tests in a real browser (Chromium, via **Playwright**, in the default configuration). The alternative is a simulated browser environment, like JSDom or HappyDom, which can have differences in behavior compared to a real browser. This allows to run your tests in the browser natively, providing access to browser globals like window and document, and use Playwright for cross-browser testing.

Sources:
-  https://storybook.js.org/docs/writing-tests/integrations/vitest-addon#why-do-we-recommend-browser-mode
- https://www.defined.net/blog/modern-frontend-testing/

## Background: Motivation and History

The article [Building a Reading List web app with Node, Preact, and Tailwind CSS](https://dev.to/ingosteinke/building-a-reading-list-web-app-with-node-preact-and-tailwind-css-44pa) elaborates on my motivation and project history.

This should have been the first project based on my [Tailwind-JIT-MERN-Starter](https://github.com/openmindculture/tailwind-jit-mern),
which was forked from [Retinafunk's Tailwind-JIT-Starter](https://github.com/retinafunk/tailwind-jit).

[I](https://www.ingo-steinke.com/) migrated it to a simpler proof of concept demo using Astro in 2024 using the Astro Starter Kit and current documentation and tutorials. Development stopped shortly after, due to prioritized paid customer projects. Proceeding in June 2025, inspired by the React Berlin Meetup, Hunor MÃ¡rtonÂ´s Astro+React talk, feedback from Freelance Unlocked workshops and AI-assisted "CV hacking" sessions, as well as feedback from fellow developers about the latest advances in AI-assisted coding, the development process and tech stack changed, once again, but only slightly, to Astro + React + Storybook + Tailwind + Vite + Vitest + Playwright, a clear frontend focus with no backend logic like dynamic API, database or serverless functions at all, and including LLM-based coding assistants like Copilot, Windsurf, Gemini, and Jetbrains AI, which is still the preferred AI assistant due to its stability and long-term development by a reputable European company.

## Roadmap
- [x] start initial proof of concept
- [x] document ideas and roadmap
- [x] register domain
- [x] release placeholder text with backlinks
- [x] update requirements and prioritization
  - [x] no backend, 100% focus on the front-end
  - [x] Tailwind without optional extras
  - [x] React (keep it simple and stick to the mainstream)
  - [x] Astro
  - [x] Playwright
- [x] release a minimal viable product/page (MVP)
- [x] research, experiment, and decide on a tech stack
- [x] document requirements and guidelines
- [ ] run audits and document results (Lighthouse, WAVE, WebPageTest, WebsiteCarbon, Green Web Check, and optional services Domain Authority, SEObility, Ubersuggest etc.)
- [ ] list and link the web app to increase incoming backlinks
- [ ] increase test coverage
  - [ ] unit tests
  - [ ] end-to-end tests
  - [ ] frontend tests, including Screenshots and accessibility audits
- [ ] localize app (German and English)
- [ ] add more content

<a id="software-architecture-research-and-decisions"></a>
## Software Architecture Research and Decisions

### Common Modules for Astro, React, and Storybook

> In an Astro project, how can we ensure that the same components can be prototyped and testing in storybook and reused both for static Astro rendering and as part of a dynamic react app?

Seasoned astronaut:

> ðŸ§‘â€ðŸš€ Delete this section. Have fun!

### Project Structure

Inside of your Astro project, you'll see the following folders and files:

```text
/
â”œâ”€â”€ public/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ pages/
â”‚       â””â”€â”€ index.astro
â””â”€â”€ package.json
```

Astro looks for `.astro` or `.md` files in the `src/pages/` directory. Each page is exposed as a route based on its file name.

There's nothing special about `src/components/`, but that's where we like to put any Astro/React/Vue/Svelte/Preact components.

Any static assets, like images, can be placed in the `public/` directory.

### ðŸ§ž AstroÂ´s Basic Commands

All commands are run from the root of the project, from a terminal:

| Command                   | Action                                           |
| :------------------------ | :----------------------------------------------- |
| `npm install`             | Installs dependencies                            |
| `npm run dev`             | Starts local dev server at `localhost:4321`      |
| `npm run build`           | Build your production site to `./dist/`          |
| `npm run preview`         | Preview your build locally, before deploying     |
| `npm run astro ...`       | Run CLI commands like `astro add`, `astro check` |
| `npm run astro -- --help` | Get help using the Astro CLI                     |

### Additional Astro Commands

`npm run test` | run all tests
`npm run eslint` | check TypeScript and JS files for correct syntax and best practices

### Build Tools: npm vs. yarn vs. bun vs. ...

> Should we use yarn instead of npm in a project with astro, vite, and react?

For most projects and teams, **npm is a perfectly solid choice**. It's the default, well-understood, and has improved immensely. Consider Yarn, especially Yarn Berry, if you are working in a monorepo and want robust workspace support. Consider pnpm if disk space efficiency is a major concern. Consider Bun if you are starting a new project and you're ready to experiment with a fast, cutting edge tool, that is probably less stable and mature than Yarn or npm. Once you decide (or confirm) the package manager to use, always commit the corresponding lock file.

### Vite vs. Parcel vs. webpack vs. ...

**Vite** heavily leverages esbuild, but it's not built entirely on top of esbuild in the sense that esbuild handles everything. Vite uses esbuild for specific, performance-critical tasks, and combines it with other tools for a complete development and build experience.

**Vite uses esbuild as a transpiler and pre-bundler** during development and for minification, but **relies on Rollup for the more complex production bundling** and its extensive plugin ecosystem. The eventual **plan is to consolidate these roles with Rolldown**.
